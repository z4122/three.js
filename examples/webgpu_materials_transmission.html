<!DOCTYPE html>
<html lang="en">
	<head>
		<title>threejs webgpu - materials - transmission</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">threejs</a> webgpu - transmission</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
import * as THREE from "three";
import { ArcballControls, WebGL } from "three/addons/Addons.js";
import WebGPU from "three/addons/capabilities/WebGPU.js";
import WebGPURenderer from "three/addons/renderers/webgpu/WebGPURenderer.js";

const renderTarget = document.body;
let renderer;
let camera;
let controls;
let scene;
let mesh1;
let mesh2
const total = 20;
let objs = [];

if (WebGPU.isAvailable() === false && WebGL.isWebGL2Available() === false) {
  document.body.appendChild(WebGPU.getErrorMessage());
  throw new Error('No WebGPU or WebGL2 support');
}

function OnWindowResize() {
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(renderTarget.parentElement.clientWidth, renderTarget.parentElement.clientHeight);
  camera.aspect = renderTarget.parentElement.clientWidth / renderTarget.parentElement.clientHeight;
  camera.updateProjectionMatrix();
}

// stuff

function update() {
  if (mesh1) {
    objs.forEach((o, idx) => {
      mesh1.setMatrixAt(idx, o.matrix);
    });
    mesh1.instanceMatrix.needsUpdate = true;
  }

  if (mesh2) {
    objs.forEach((o, idx) => {
      mesh2.setMatrixAt(idx, o.matrix);
    });
    mesh2.instanceMatrix.needsUpdate = true;
  }
}

async function render() {
  await renderer.render(scene, camera);
}

function animate() {
  update();
  render();
}

// meat

camera = new THREE.PerspectiveCamera(45, renderTarget.parentElement.clientWidth / renderTarget.parentElement.clientWidth, 0.1, 10000);
camera.aspect = renderTarget.parentElement.clientWidth / renderTarget.parentElement.clientHeight;
camera.position.set(0, 2, 10);

scene = new THREE.Scene();

const sun = new THREE.PointLight(0xffffff, 1000);
sun.position.set(-100, 500, -100);
scene.add(sun);

const sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
const sphereGeometry = new THREE.SphereGeometry(0.6);
const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
scene.add(sphere);

const meshMaterial = new THREE.MeshBasicMaterial({ color: THREE.Color.NAMES.green });
const meshGeometry = new THREE.BoxGeometry(1);
mesh1 = new THREE.InstancedMesh(meshGeometry, meshMaterial, total);
mesh1.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(mesh1);

for (let i = 0; i < total; i++) {
  let o = new THREE.Object3D();
  o.position.set(i * 5, 0.5, 0);
  o.updateMatrix();
  objs.push(o);
  mesh1.setMatrixAt(i, o.matrix);
}
mesh1.instanceMatrix.needsUpdate = true;

mesh2 = new THREE.InstancedMesh(meshGeometry, meshMaterial, total);
mesh2.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(mesh2);

for (let i = 0; i < total; i++) {
  let o = new THREE.Object3D();
  o.position.set(i * 5, 2, 2);
  o.updateMatrix();
  objs.push(o);
  mesh2.setMatrixAt(i, o.matrix);
}
mesh2.instanceMatrix.needsUpdate = true;

renderer = new WebGPURenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(renderTarget.parentElement.clientWidth, renderTarget.parentElement.clientHeight);
renderer.setAnimationLoop(animate);
renderTarget.appendChild(renderer.domElement);

controls = new ArcballControls(camera, renderer.domElement);
controls.cursorZoom = true;


// register event listeners

window.addEventListener("resize", OnWindowResize);
		</script>
	</body>
</html>